# Activity

Класс Activity является ключевым компонентом приложения для Android, а способ запуска и объединения активностей представляет собой фундаментальную часть модели приложений платформы. В отличие от парадигм программирования, где приложения запускаются с помощью метода main(), система Android инициирует код в экземпляре Activity, вызывая определённые методы обратного вызова, соответствующие конкретным стадиям его жизненного цикла.

Концепция activity

Мобильное приложение отличается от настольного аналога тем, что взаимодействие пользователя с приложением не всегда начинается с одной и той же точки. Вместо этого путь пользователя часто не имеет единой точки входа. Например, если вы откроете почтовое приложение с главного экрана, вы увидите список писем. Однако если вы используете приложение для социальных сетей, которое затем запускает ваше почтовое приложение, вы можете сразу перейти к экрану составления письма.

Класс Activity разработан для поддержки этой парадигмы. Когда одно приложение вызывает другое, вызывающее приложение активирует активность в другом приложении, а не приложение целиком. Таким образом, активность служит точкой входа для взаимодействия приложения с пользователем. Вы реализуете активность как подкласс класса Activity.

Активность предоставляет окно, в котором приложение отображает свой пользовательский интерфейс. Это окно обычно занимает весь экран, но может быть меньше и располагаться поверх других окон. Как правило, одна активность реализует один экран в приложении. Например, одна активность может реализовать экран настроек, а другая — экран выбора фотографии.

Обычно одна активность в приложении обозначается как MainActivity — это первый экран, который появляется при запуске приложения пользователем.

Для использования активностей в приложении необходимо зарегистрировать информацию о них в манифесте приложения и корректно управлять жизненным циклом активностей.

Манифест

<manifest ... >
<application ... >
<activity android:name=".ExampleActivity" />
...
</application ... >
...
</manifest >

Жизненный цикл

За время своего существования активность проходит через несколько состояний. Вы используете серию обратных вызовов для управления переходами между состояниями.

Метод onCreate() вызывается при создании активности. Внутри этого метода настраивается статический интерфейс активности. Инициализируются статические данные активности, связываются данные со списками и т.д. Обязательно вызывается метод setContentView(layout).

Далее onStart(). Когда активность находится в состоянии STARTED, пользователь ещё не видит активность.

Далее onResume(). Если активность в состоянии RESUMED, приложение находится в приоритетном режиме, пользователь видит активность и может с ней взаимодействовать. Можно воспроизводить анимации, аудио и видео.

Далее onPause(). Этот метод вызывается отдельно только в случае, если пользователь может видеть активность, но не может с ней взаимодействовать. Например, когда пользователю поступает звонок. Теоретически этот метод можно использовать для приостановки активных действий и анимаций. Если пользователь вернётся к взаимодействию с активностью, будет снова вызван метод onResume().

Если пользователь покидает активность или приложение, вызывается метод onStop().

Далее, если пользователь возвращается к приложению, будет вызван метод onRestart(), затем снова onStart(), onResume(). Либо будет вызван onDestroy(), если активность уничтожается.

Что касается метода onDestroy(), он не вызывается, если приложение будет убито системой из-за нехватки ресурсов.

Также можно переопределить методы onSaveInstanceState() и onRestoreInstanceState() для сохранения и восстановления состояния соответственно.

Задачи и стек возврата (Tasks and Back Stack)

О задачах (Tasks):

Когда приложения работают одновременно в многооконной среде, поддерживаемой в Android 7.0 (API уровень 24) и выше, система управляет задачами отдельно для каждого окна; каждое окно может содержать несколько задач. То же самое относится к приложениям Android, работающим на Chromebook: система управляет задачами или группами задач для каждого окна.

Задача — это целостная единица, которая может быть перемещена в "фон", когда пользователь начинает новую задачу или переходит на главный экран через кнопку "Домой".

Режим запуска (launchMode):

1. standard

2. singleTop (FLAG_ACTIVITY_SINGLE_TOP): стандартный режим или вызов onNewIntent().

3. singleTask (FLAG_ACTIVITY_NEW_TASK): система создаёт новую задачу и размещает активность в корне новой задачи. Однако если экземпляр активности уже существует в отдельной задаче, система перенаправляет намерение к существующему экземпляру через вызов метода onNewIntent(), вместо создания нового экземпляра. Одновременно может существовать только один экземпляр активности.

Это означает, что если ваше приложение отправляет намерение открыть браузер Android, его активность не помещается в ту же задачу, что и ваше приложение. Вместо этого либо начинается новая задача для браузера, либо, если у браузера уже есть задача в фоновом режиме, эта задача выводится на передний план для обработки нового намерения.

4. singleInstance: То же, что и singleTask, за исключением того, что система не запускает другие активности в задачу, содержащую этот экземпляр. Активность всегда является единственным членом своей задачи; любые активности, запущенные этой активностью, открываются в отдельной задаче.

FLAG_ACTIVITY_CLEAR_TOP

Если запускаемая активность уже работает в текущей задаче, то вместо создания нового экземпляра этой активности все активности поверх неё уничтожаются, и намерение доставляется возобновлённому экземпляру активности (теперь находящемуся сверху) через onNewIntent().

Нет значения атрибута launchMode, которое бы обеспечивало такое поведение.

FLAG_ACTIVITY_CLEAR_TOP чаще всего используется вместе с FLAG_ACTIVITY_NEW_TASK. В сочетании эти флаги позволяют найти существующую активность в другой задаче и поставить её в положение, где она может ответить на намерение.

Управление привязкой (Handling affinities)

Привязка (affinity) указывает, к какой задаче активность предпочитает относиться. По умолчанию все активности из одного приложения имеют привязку друг к другу. Таким образом, по умолчанию все активности одного приложения предпочитают находиться в одной задаче. Однако вы можете изменить привязку по умолчанию для активности. Активности, определённые в разных приложениях, могут иметь общую привязку, или активности в одном приложении могут быть назначены разные привязки задач.

Вы можете изменить привязку для любой активности с помощью атрибута taskAffinity элемента <activity>.

Атрибут taskAffinity принимает строковое значение, которое должно отличаться от имени пакета по умолчанию, указанного в элементе <manifest>, поскольку система использует это имя для определения привязки задачи по умолчанию для приложения.

Привязка играет роль в двух случаях:

1. Когда намерение, запускающее активность, содержит флаг FLAG_ACTIVITY_NEW_TASK.

2. Когда у активности установлен атрибут allowTaskReparenting в значение "true". В этом случае активность может перемещаться из задачи, в которой она запущена, в задачу, к которой она имеет привязку, когда эта задача выходит на передний план.

Например, предположим, что активность, сообщающая о погоде в выбранных городах, определена как часть туристического приложения. Она имеет такую же привязку, как и другие активности в этом приложении (привязка приложения по умолчанию), и позволяет переназначение с помощью этого атрибута. Когда одна из ваших активностей запускает активность прогноза погоды, она изначально принадлежит той же задаче, что и ваша активность. Однако, когда задача туристического приложения выходит на передний план, активность прогноза погоды переназначается в эту задачу и отображается в ней.

Очистка стека возврата (Clearing the back stack)

Если пользователь надолго покидает задачу, система очищает задачу от всех активностей, кроме корневой активности. Когда пользователь возвращается к задаче, восстанавливается только корневая активность. Система ведёт себя так, потому что после длительного времени пользователи, скорее всего, забросили то, что делали ранее, и возвращаются к задаче, чтобы начать что-то новое.

Некоторые атрибуты активности позволяют изменить это поведение:

1. alwaysRetainTaskState: Если этот атрибут установлен в "true" в корневой активности задачи, описанное выше поведение по умолчанию не происходит. Задача сохраняет все активности в своём стеке даже после длительного периода.

2. clearTaskOnLaunch: Если этот атрибут установлен в "true" в корневой активности задачи, задача очищается до корневой активности каждый раз, когда пользователь покидает задачу и возвращается к ней. Другими словами, это противоположность alwaysRetainTaskState. Пользователь всегда возвращается к задаче в её начальном состоянии, даже после кратковременного ухода.

Примечание: Этот атрибут игнорируется, если не установлен флаг FLAG_ACTIVITY_RESET_TASK_IF_NEEDED.

3. finishTaskOnLaunch: Этот атрибут похож на clearTaskOnLaunch, но действует на одну активность, а не на всю задачу. Он также может завершить любую активность, кроме корневой. Когда установлен в "true", активность остаётся частью задачи только на текущую сессию. Если пользователь уходит и затем возвращается к задаче, она больше не присутствует.

Примечание: Этот атрибут игнорируется, если не установлен флаг FLAG_ACTIVITY_RESET_TASK_IF_NEEDED.

Запуск задачи (Starting a task)

Вы можете настроить активность как точку входа для задачи, задав ей фильтр намерений с указанием действия "android.intent.action.MAIN" и категории "android.intent.category.LAUNCHER".

Эта вторая возможность важна: пользователи должны иметь возможность покинуть задачу и позже вернуться к ней с помощью этого запускающего активность элемента. Поэтому два режима запуска, которые всегда инициируют задачу — "singleTask" и "singleInstance" — следует использовать только тогда, когда у активности есть фильтр ACTION_MAIN и CATEGORY_LAUNCHER. Представьте, что может произойти, если фильтр отсутствует: намерение запускает активность "singleTask", инициируя новую задачу, и пользователь проводит некоторое время, работая в этой задаче. Затем пользователь нажимает кнопку "Домой". Задача отправляется в фоновый режим и становится невидимой. Теперь у пользователя нет способа вернуться к задаче, потому что она не представлена в лаунчере приложений.
